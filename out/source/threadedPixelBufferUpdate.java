/* autogenerated by Processing revision 1295 on 2025-03-10 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.concurrent.ThreadLocalRandom;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class threadedPixelBufferUpdate extends PApplet {



float scale = 1;
float scale_start = 1;
float scale_goto = 100;

volatile PImage buffer;
boolean PAUSE = false;

public void setup() {
	/* size commented out by preprocessor */;
	frameRate(120);

	// disable anti aliasing
	hint(DISABLE_TEXTURE_MIPMAPS);
	((PGraphicsOpenGL)g).textureSampling(2);

	buffer = createImage(PApplet.parseInt(width), PApplet.parseInt(height), RGB);
	buffer.loadPixels();
	imageMode(CENTER);
}


public void draw() {
	background(0);
	pushMatrix();
	translate(width/2, height/2, 0);
	scale = 1.0f;
	scale(scale); // zoom into the screen
	if (!PAUSE) {
		ArrayList tasks = new ArrayList();
		int thread_splite = 1; // number of threads for pixel updates. 1 = no thread. find the sweet spot for you CPU
		for (int i = 0; i < thread_splite; i++) {
		Thread thread = new updateBuffer(i, ((width/thread_splite)*i), 0, ((width/thread_splite)*(i+1)), width);
		thread.start();
		tasks.add(thread);
		}
		try {
		for (int i = 0; i < thread_splite; i++) {
			Thread thread =(Thread)tasks.get(i);
			thread.join();
		}
		}
		catch (InterruptedException e) {
		e.printStackTrace();
		}

		buffer.updatePixels();
	}
	image(buffer, 0, 0, width, height);
	popMatrix();
	fill(255);
	textSize(30);
	text("fps: "+(int) frameRate, 50, 50);
}

public void keyReleased() {
	if (key == ' ') {
		PAUSE =!PAUSE;
	}
}
 
class PerlinNoise {
    private int[] perm = new int[512];

    public PerlinNoise() {
        int[] p = new int[256];
        for (int i = 0; i < 256; i++) p[i] = i;

        // Shuffle the permutation table
        for (int i = 255; i > 0; i--) {
            int j = (int) (Math.random() * (i + 1));
            int tmp = p[i];
            p[i] = p[j];
            p[j] = tmp;
        }

        // Duplicate the permutation table
        for (int i = 0; i < 512; i++) perm[i] = p[i & 255];
    }

	public float noise(float x) {
		int X = (int) Math.floor(x) & 255;
		x -= Math.floor(x);
		float u = fade(x);

		float rawNoise = lerp(u, grad(perm[X], x), grad(perm[X + 1], x - 1));

		return (rawNoise + 1) * 0.5f;  // Normalize to 0 - 1 range
	}

    private float fade(float t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    private float lerp(float t, float a, float b) {
        return a + t * (b - a);
    }

    private float grad(int hash, float x) {
        return (hash & 1) == 0 ? x : -x;
    }
}
public int xy2i(int xin, int yin) {
  int x = xin;
  int y = yin;
  if (xin < 0) {
    x = buffer.width - abs(xin);
  }
  if (yin < 0) {
    y = buffer.height - abs(yin);
  }
  return(x % buffer.width) +((y % buffer.height) * buffer.width);
}
// Fast integer randon function
public static int intRandom(int min, int max) {
   return ThreadLocalRandom.current().nextInt(min, max + 1);
}
class updateBuffer extends Thread {
	int id = 0;
	int fromX = 0;
	int fromY = 0;
	int toX = 0;
	int toY = 0;

	PerlinNoise perlin = new PerlinNoise();
	float noiseIncR = 1.0f;
	float noiseIncG = 1.0f;
	float noiseIncB = 1.0f;

	updateBuffer(int _id, int _fromX, int _fromY, int _toX, int _toY) {
		id = _id;
		fromX = _fromX;
		fromY = _fromY;
		toX = _toX;
		toY = _toY;
	}

	public void run() {

		for (int x = fromX; x < toX; x++) {
			for (int y = fromY; y < toY; y++) {
				// buffer update here

				noiseIncR += random(.001f, .01f);
				noiseIncG += random(.001f, .01f);
				noiseIncB += random(.001f, .01f);

				// int r = intRandom(50, 255);
				// int g = intRandom(50, 255);
				// int b = intRandom(50, 255);

				float r = map(perlin.noise(noiseIncR), 0, 1, 50, 255);
				float g = map(perlin.noise(noiseIncG), 0, 1, 50, 255);
				float b = map(perlin.noise(noiseIncB), 0, 1, 50, 255);

				buffer.pixels[xy2i(x, y)] = 0xff000000 | ((int) (r) << 16 | (int) (g) << 8 | (int) (b));
			}
		}
  	}
}


  public void settings() { size(1000, 1000, OPENGL); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "threadedPixelBufferUpdate" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
